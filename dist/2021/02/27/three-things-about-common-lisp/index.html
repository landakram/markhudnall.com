<!DOCTYPE html>
<html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1.0" name="viewport"><title>Three things about Common Lisp | Mark Hudnall</title><script src="https://use.typekit.net/ues0olh.js"></script><script>try{Typekit.load({ async: false });}catch(e){}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><link href="/css/a40e9090fb15/main.css" rel="stylesheet"></head><body><div class="life-canvas"></div><div class="body no-pointer-events my-one flex flex-col justify-center mx-auto p-one"><div class="header pointer-events flex flex-row justify-between items-center"><div class="logo"><a href="/"><img src="/img/logo-tarot.svg"></a></div><nav class="navigation"><ul class="space-x-half"><li><a href="/">About</a></li><li><a href="/writing/">Writing</a></li><li><a href="/rss.xml">RSS</a></li></ul></nav></div><div class="prose content pointer-events mt-two"><article><div><h1 class="post-title mb-0">Three things about Common Lisp</h1><time class="post-date text-gray-600 italic mb-one inline-block">February 27, 2021</time><fieldset class="border-2 border-solid border-yellow-300 text-yellow-300 opacity-70 p-4 mb-one"><legend class="px-2">⚠️</legend><p class="m-0 p-0">This post is over 2 years old. A lot has changed since then! Take these words with a grain of salt and some patience with past me, who no longer exists.</p></fieldset><p>I continue to have my mind blown by Common Lisp. Here are three things I've been thinking about.</p><h2 id="1.&#95;error&#95;handling">1. Error handling</h2><p>Common Lisp made me realize I was living with a fixed mental model of error handling. Swimming in water, so to speak. To me, error handling meant try/catch or returning errors directly from functions a la golang or promises. In either case, control is relinquished at the error-site and bubbled up the stack to an error handler. The flow of control continues with the error handler.</p><p>The Common Lisp condition system, on the other hand, separates flow of control from the error handler. A low-level piece of code can define multiple ways to handle an error that it might throw. A higher-level function can then decide which path to actually take when the error is thrown. Control flow depends on that decision: it is possible to just skip the error and continue on with the low-level code, if that is one of the error handling options that the low-level code provides.</p><p>This is simply not possible in the try/catch paradigm without directly handling the error at the error-site, which means we lose generality: we are now stuck with a specific error handling implementation without the ability to customize.</p><p>The chapter, <a href='http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html'>Beyong Exception Handling: Conditions and Restarts</a> from Practical Common Lisp explains the condition system very well.</p><h2 id="2.&#95;dynamic&#95;variables">2. Dynamic variables</h2><p>Dynamic variables are like global variables with a twist. We are used to lexical scoping, where a variable is defined in some scope and can be accessed by any inner scope that is literally nested within the outer one. Dynamic variables, on the other hand, are "dynamically scoped". When a dynamic variable is bound to a value, this binding lives on for the duration of that scope, surviving function calls. The binding is pushed onto a stack, so when the scope ends, the binding is popped and the variable returns to its former value. This differs from a global variable, where "re-binding" the variable merely sets it to a different value.</p><p>I've seen dynamic variables before in elisp and clojure. I've almost never used them in clojure, and I've used them sparingly in emacs when it was the only possible way to customize some value for the duration of a block. I equated dynamic variables with global variables, and I've seen the messiness of relying on global variables.</p><p>In Common Lisp... they just make sense for some reason. Maybe it's the fact that they're used so much more in Common Lisp code I've been working with, but I find it incredibly useful to have a value that is "globally" accessible (but only for a certain, well-defined lifetime) and to be able to customize that variable non-locally.</p><p>I see the pitfalls too. Since any function inside a scope can set a dynamic variable, it makes data flow unclear. Very easy to forget that the variable can be set non-locally and write code that assumes the value I set 3 lines above in a <code>let</code> binding is the current one.</p><p>There's a sort of similar pitfall with the condition system: my code cannot necessarily assume that throwing an error means control will end at that location.</p><h2 id="3.&#95;interactivity">3. Interactivity</h2><p>Common Lisp is intensely interactive. It is possible (and seemingly common), for example, to embed a <a href='https://common-lisp.net/project/slime/doc/html/Setting-up-the-lisp-image.html'>Swank</a> server in a production deployment. This allows you to connect to the running production system in a REPL. You can change live data, debug problems, hotswap code, etc. You might have also heard <a href='https://www.youtube.com/watch?v=_gZK0tW8EhQ'>the story of lisp at the JPL</a>, where they debugged a problem over a REPL through space.</p><p>Interactivity is at the core of the language. Installing dependencies happens at the REPL inside the running lisp process, rather than through an out-of-process package manager. Unhandled errors automatically invoke the interactive debugger rather than panicking. Standalone executables, which are quite large, are actually lisp "images": dumps of all data from a running lisp process (running processes can be dumped and restored at any time).</p><p>This interactivity changes the programming experience dramatically. I frequently find myself writing programs from the "bottom up", starting with an inner piece that I incrementally evaluate in the REPL and build on. Moreover, the feedback loop is tight; writing lisp is <em>fun</em>. </p><p>There are drawbacks here too. The problem with "images" is that the textual code and the image can diverge. The symptoms are starting up a fresh REPL only to be greeted by "The variable FOO is unbound". The root cause is usually having set some variable during a REPL session to a value that is defined further down in the code. A minor headache, as long as it doesn't get deployed to production.</p></div></article></div><div class="footer flex flex-col justify-center items-center space-y-one"><div class="footer-logo"><img src="/img/logo.png"></div></div></div><script src="/bundles/24717e077f7e/main.js" type="text/javascript"></script><script>hljs.initHighlightingOnLoad();</script><script type="text/javascript">var _gauges = _gauges || [];
    (function() {
      var t   = document.createElement('script');
      t.type  = 'text/javascript';
      t.async = true;
      t.id    = 'gauges-tracker';
      t.setAttribute('data-site-id', '567a3795bb922a54720006b5');
      t.setAttribute('data-track-path', 'https://track.gaug.es/track.gif');
      t.src = 'https://track.gaug.es/track.js';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(t, s);
    })();</script></body></html>